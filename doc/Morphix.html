    <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.18.3">
    <title>Morphix â€“ morphix v0.5.0</title>
    <link rel="stylesheet" href="dist/app-091c05798a.css" />
    
    <script src="dist/sidebar_items-45a4f8fbb8.js"></script>
    
    
    
    
  </head>
  <body data-type="modules">
    <script>try { if(localStorage.getItem('night-mode')) document.body.className += ' night-mode'; } catch (e) { }</script>

    <div class="main">
<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" aria-hidden="true"></span>
  <span class="sr-only">Toggle Sidebar</span>
</button>
<button class="sidebar-button night-mode-toggle">
  <span class="icon-theme" aria-hidden="true"></span>
  <span class="sr-only">Toggle Theme</span>
</button>
<section class="sidebar">

  
  <a href="api-reference.html" class="sidebar-projectLink">
    <div class="sidebar-projectDetails">
      <h1 class="sidebar-projectName">
        morphix
      </h1>
      <h2 class="sidebar-projectVersion">
        v0.5.0
      </h2>
    </div>
    
  </a>

  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button">
      <span class="icon-search" aria-hidden="true"></span>
    </button>
    <input name="q" type="text" id="search-list" class="search-input" placeholder="Search" aria-label="Search" autocomplete="off" />
  </form>

  <ul class="sidebar-listNav">
    <li><a id="extras-list" href="#full-list">Pages</a></li>

    
      <li><a id="modules-list" href="#full-list">Modules</a></li>
    

    

    
  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">


      <h1>
        <small class="visible-xs">morphix v0.5.0</small>
        Morphix
        
      </h1>

      
        <section id="moduledoc">
          <p>Morphix provides convenience methods for dealing with Maps, Lists, and Tuples.</p>
<p><a href="#morphiflat/1"><code class="inline">morphiflat/1</code></a> and <a href="#morphiflat!/1"><code class="inline">morphiflat!/1</code></a> flatten maps, discarding top level keys.</p>
<h3 id="module-examples" class="section-heading">
  <a href="#module-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.morphiflat %{flatten: %{this: &quot;map&quot;}, if: &quot;you please&quot;}
{:ok, %{this: &quot;map&quot;, if: &quot;you please&quot;}}

iex&gt; Morphix.morphiflat! %{flatten: %{this: &quot;map&quot;}, o: &quot;k&quot;}
%{this: &quot;map&quot;, o: &quot;k&quot;}
</code></pre>
<p><a href="#morphify!/2"><code class="inline">morphify!/2</code></a> and <a href="#morphify/2"><code class="inline">morphify/2</code></a> will take either a List or a Tuple as the first argument, and a function as the second. Returns a map, with the keys of the map being the function applied to each member of the input.</p>
<h3 id="module-examples" class="section-heading">
  <a href="#module-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.morphify!({[1,2,3], [12], [1,2,3,4]}, &amp;length/1)
%{1 =&gt; [12], 3 =&gt; [1,2,3], 4 =&gt; [1,2,3,4]}
</code></pre>
<p><a href="#atomorphify/1"><code class="inline">atomorphify/1</code></a> and <a href="#atomorphiform/1"><code class="inline">atomorphiform/1</code></a> take a map as an input and return the map with all string keys converted to atoms. <a href="#atomorphiform/1"><code class="inline">atomorphiform/1</code></a> is recursive. <a href="#atomorphiform/2"><code class="inline">atomorphiform/2</code></a> and <code class="inline">atomormiphify/2</code> take <code class="inline">:safe</code> as a second argument, they will not convert string keys if the resulting atom has not been defined.</p>
<h3 id="module-examples" class="section-heading">
  <a href="#module-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.atomorphify(%{&quot;a&quot; =&gt; &quot;2&quot;, :a =&gt; 2, &#39;a&#39;  =&gt; :two})
{:ok, %{:a =&gt; 2, &#39;a&#39; =&gt; :two }}
</code></pre>
<p><code class="inline">compactify</code> and <code class="inline">compactiform</code> take a map or list as an input and returns a filtered map or list, removing any keys or elements with nil values or with an empty map as a value.</p>
<p><a href="#partiphify!/2"><code class="inline">partiphify!/2</code></a> and <a href="#partiphify/2"><code class="inline">partiphify/2</code></a> take a list <code class="inline">l</code> and an integer <code class="inline">k</code> and partition <code class="inline">l</code> into <code class="inline">k</code> sublists of balanced size. There will always be <code class="inline">k</code> lists, even if some must be empty.</p>
<h3 id="module-examples" class="section-heading">
  <a href="#module-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.partiphify!([:a, :b, :c, :d, :e, :f], 4)
[[:c], [:d], [:e, :a], [:f, :b]]

iex&gt; Morphix.partiphify!([:a, :b, :c, :d, :e], 4)
[[:b], [:c], [:d], [:e, :a]]

iex&gt; Morphix.partiphify!([:a, :b, :c, :d], 4)
[[:a], [:b], [:c], [:d]]

iex&gt; Morphix.partiphify!([:a, :b, :c], 4)
[[:a], [:b], [:c], []]
</code></pre>
<p><a href="#equaliform?/2"><code class="inline">equaliform?/2</code></a> compares two ordered or unordered lists and returns <code class="inline">true</code> if they are equal.</p>
<h3 id="module-example" class="section-heading">
  <a href="#module-example" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Example:
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.equaliform?([1, [&quot;two&quot;, :three], %{a: 1, c: &quot;three&quot;, e: %{d: 4, b: 2}}], [[&quot;two&quot;, :three], 1, %{c: &quot;three&quot;, a: 1, e: %{b: 2, d: 4}}])
true

iex&gt; Morphix.equaliform?(%{a: 1, b: 2, c: 3}, %{b: 2, c: 3, a: 1})
** (ArgumentError) expecting a list for each parameter, got: %{a: 1, b: 2, c: 3}, %{a: 1, b: 2, c: 3}</code></pre>

        </section>
      

      
        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
            Summary
          </h1>
          

          
  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
    <div class="summary-row">
  <div class="summary-signature">
    <a href="#atomorphiform/1">atomorphiform(map)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a map as an argument and returns <code class="inline">{:ok, map}</code>, with all string keys (including keys in nested maps) converted to atom keys</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#atomorphiform/2">atomorphiform(map, allowed)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a map and a list of allowed strings as arguments and returns <code class="inline">{:ok, map}</code>, with any strings that are in the list converted to atoms, and any strings that are not in the list left as strings</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#atomorphiform!/1">atomorphiform!(map)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a map as an argument and returns the same map, with all string keys (including keys in nested maps) converted to atom keys</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#atomorphiform!/2">atomorphiform!(map, allowed)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a map and a list of allowed strings as arguments and returns the same map, with any strings that are in the list converted to atoms, and any strings that are not in the list left as strings</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#atomorphify/1">atomorphify(map)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a map as an argument and returns <code class="inline">{:ok, map}</code>, with string keys converted to atom keys. Does not examine nested maps</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#atomorphify/2">atomorphify(map, allowed)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a map and a list of allowed strings to convert to atoms and returns <code class="inline">{:ok, map}</code>, with string keys in the list converted to atoms. Ignores nested maps</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#atomorphify!/1">atomorphify!(map)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a map as an argument and returns the same map with string keys converted to atom keys. Does not examine nested maps</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#atomorphify!/2">atomorphify!(map, allowed)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a map and a list of allowed strings to convert to atoms and returns the same map, with string keys in the list converted to atoms. Ignores nested maps</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#compactiform/1">compactiform(map)</a>
  </div>
  
    <div class="summary-synopsis"><p>Removes keys with nil values from maps and nil elements from lists. It also handles nested maps and lists, and treats empty maps as nil values</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#compactiform!/1">compactiform!(map)</a>
  </div>
  
    <div class="summary-synopsis"><p>Removes keys with nil values from nested maps, eliminates empty maps, and removes nil values from nested lists</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#compactify/1">compactify(map_or_list)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a map or a list and removes any keys or elements that have nil values</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#compactify!/1">compactify!(map)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a map or list and removes keys or elements that have nil values, or are empty maps</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#equaliform?/2">equaliform?(list1, list2)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes two ordered or unordered lists and returns <code class="inline">true</code> if they are equal</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#morphiflat/1">morphiflat(map)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a map and returns a flattened version of that map. If the map has nested maps (or the maps nested maps have nested maps, etc.) morphiflat moves all nested key/value pairs to the top level, discarding the original keys</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#morphiflat!/1">morphiflat!(map)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a map and returns a flattend version of that map, discarding any nested keys</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#morphify/2">morphify(enum, funct)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a List and a function as arguments and returns <code class="inline">{:ok, Map}</code>, with the keys of the map the result of applying the function to each item in the list</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#morphify!/2">morphify!(enum, funct)</a>
  </div>
  
    <div class="summary-synopsis"><p>Takes a list and a function as arguments and returns a Map, with the keys of the map the result of applying the function to each item in the list</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#partiphify/2">partiphify(list, k)</a>
  </div>
  
    <div class="summary-synopsis"><p>Divides a list into k distinct sub-lists, with partitions being as close to the same size as possible</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#partiphify!/2">partiphify!(list, k)</a>
  </div>
  
    <div class="summary-synopsis"><p>Divides a list into k distinct sub-lists, with partitions being as close to the same size as possible</p>
</div>
  
</div>

  </div>


          

        </section>
      

      

      
        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
            Functions
          </h1>
          <div class="detail" id="atomorphiform/1">
  
  
  <div class="detail-header">
    <a href="#atomorphiform/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">atomorphiform(map)</span>
    
    
    
      <div class="specs">
        
          <pre>atomorphiform(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()) :: {:ok, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a map as an argument and returns <code class="inline">{:ok, map}</code>, with all string keys (including keys in nested maps) converted to atom keys.</p>
<h3 id="atomorphiform/1-examples" class="section-heading">
  <a href="#atomorphiform/1-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.atomorphiform(%{:this =&gt; %{map: %{&quot;has&quot; =&gt; &quot;a&quot;, :nested =&gt; &quot;string&quot;, :for =&gt;  %{a: :key}}}, &quot;the&quot; =&gt;  %{&quot;other&quot; =&gt; %{map: :does}}, as: &quot;well&quot;})
{:ok,%{this: %{map: %{has: &quot;a&quot;, nested: &quot;string&quot;, for: %{a: :key}}}, the: %{other: %{map: :does}}, as: &quot;well&quot;} }

iex&gt; Morphix.atomorphiform(%{&quot;this&quot; =&gt; [&quot;map&quot;, %{&quot;has&quot; =&gt; [&quot;a&quot;, &quot;list&quot;]}], &quot;inside&quot; =&gt; &quot;it&quot;})
{:ok, %{this: [&quot;map&quot;, %{has: [&quot;a&quot;, &quot;list&quot;]}], inside: &quot;it&quot;}}
</code></pre>

  </section>
</div>
<div class="detail" id="atomorphiform/2">
  
  
  <div class="detail-header">
    <a href="#atomorphiform/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">atomorphiform(map, allowed)</span>
    
    
    
      <div class="specs">
        
          <pre>atomorphiform(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(), :safe) :: {:ok, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()}</pre>
        
          <pre>atomorphiform(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>()) :: {:ok, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a map and a list of allowed strings as arguments and returns <code class="inline">{:ok, map}</code>, with any strings that are in the list converted to atoms, and any strings that are not in the list left as strings.</p>
<p>Works recursively on embedded maps.</p>
<h3 id="atomorphiform/2-examples" class="section-heading">
  <a href="#atomorphiform/2-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; map = %{&quot;memberof&quot; =&gt; &quot;atoms&quot;, &quot;embed&quot; =&gt; %{&quot;will&quot; =&gt; &quot;convert&quot;, &quot;thelist&quot; =&gt; &quot;to atoms&quot;}}
iex&gt; Morphix.atomorphiform(map, [&quot;memberof&quot;, &quot;thelist&quot;])
{:ok, %{&quot;embed&quot; =&gt; %{&quot;will&quot; =&gt; &quot;convert&quot;, thelist: &quot;to atoms&quot;}, memberof: &quot;atoms&quot;}}
</code></pre>

  </section>
</div>
<div class="detail" id="atomorphiform!/1">
  
  
  <div class="detail-header">
    <a href="#atomorphiform!/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">atomorphiform!(map)</span>
    
    
    
      <div class="specs">
        
          <pre>atomorphiform!(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()) :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a map as an argument and returns the same map, with all string keys (including keys in nested maps) converted to atom keys.</p>
<h3 id="atomorphiform!/1-examples" class="section-heading">
  <a href="#atomorphiform!/1-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.atomorphiform!(%{:this =&gt; %{map: %{&quot;has&quot; =&gt; &quot;a&quot;, :nested =&gt; &quot;string&quot;, :for =&gt;  %{a: :key}}}, &quot;the&quot; =&gt;  %{&quot;other&quot; =&gt; %{map: :does}}, as: &quot;well&quot;})
%{this: %{map: %{has: &quot;a&quot;, nested: &quot;string&quot;, for: %{a: :key}}}, the: %{other: %{map: :does}}, as: &quot;well&quot;}

iex&gt; Morphix.atomorphiform!(%{&quot;this&quot; =&gt; [&quot;map&quot;, %{&quot;has&quot; =&gt; [&quot;a&quot;, &quot;list&quot;]}], &quot;inside&quot; =&gt; &quot;it&quot;})
%{this: [&quot;map&quot;, %{has: [&quot;a&quot;, &quot;list&quot;]}], inside: &quot;it&quot;}
</code></pre>

  </section>
</div>
<div class="detail" id="atomorphiform!/2">
  
  
  <div class="detail-header">
    <a href="#atomorphiform!/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">atomorphiform!(map, allowed)</span>
    
    
    
      <div class="specs">
        
          <pre>atomorphiform!(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(), :safe) :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()</pre>
        
          <pre>atomorphiform!(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>()) :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a map and a list of allowed strings as arguments and returns the same map, with any strings that are in the list converted to atoms, and any strings that are not in the list left as strings.</p>
<p>Works recursively on embedded maps.</p>
<h3 id="atomorphiform!/2-examples" class="section-heading">
  <a href="#atomorphiform!/2-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; map = %{&quot;memberof&quot; =&gt; &quot;atoms&quot;, &quot;embed&quot; =&gt; %{&quot;will&quot; =&gt; &quot;convert&quot;, &quot;thelist&quot; =&gt; &quot;to atoms&quot;}}
iex&gt; Morphix.atomorphiform!(map, [&quot;memberof&quot;, &quot;thelist&quot;])
%{&quot;embed&quot; =&gt; %{&quot;will&quot; =&gt; &quot;convert&quot;, thelist: &quot;to atoms&quot;}, memberof: &quot;atoms&quot;}
</code></pre>
<pre><code class="iex elixir">iex&gt; map = %{&quot;id&quot; =&gt; &quot;fooobarrr&quot;, &quot;date_of_birth&quot; =&gt; ~D[2014-04-14]}
%{&quot;date_of_birth&quot; =&gt; ~D[2014-04-14], &quot;id&quot; =&gt; &quot;fooobarrr&quot;}
iex&gt; Morphix.atomorphiform!(map)
%{id: &quot;fooobarrr&quot;, date_of_birth: ~D[2014-04-14]}</code></pre>

  </section>
</div>
<div class="detail" id="atomorphify/1">
  
  
  <div class="detail-header">
    <a href="#atomorphify/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">atomorphify(map)</span>
    
    
    
      <div class="specs">
        
          <pre>atomorphify(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()) :: {:ok, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a map as an argument and returns <code class="inline">{:ok, map}</code>, with string keys converted to atom keys. Does not examine nested maps.</p>
<h3 id="atomorphify/1-examples" class="section-heading">
  <a href="#atomorphify/1-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.atomorphify(%{&quot;this&quot; =&gt; &quot;map&quot;, &quot;has&quot; =&gt; %{&quot;string&quot; =&gt; &quot;keys&quot;}})
{:ok, %{this: &quot;map&quot;, has: %{&quot;string&quot; =&gt; &quot;keys&quot;}}}

iex&gt; Morphix.atomorphify(%{1 =&gt; &quot;2&quot;, &quot;1&quot; =&gt; 2, &quot;one&quot; =&gt; :two})
{:ok, %{1 =&gt; &quot;2&quot;, &quot;1&quot;: 2, one: :two}}
</code></pre>

  </section>
</div>
<div class="detail" id="atomorphify/2">
  
  
  <div class="detail-header">
    <a href="#atomorphify/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">atomorphify(map, allowed)</span>
    
    
    
      <div class="specs">
        
          <pre>atomorphify(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(), :safe) :: {:ok, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()}</pre>
        
          <pre>atomorphify(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>()) :: {:ok, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a map and a list of allowed strings to convert to atoms and returns <code class="inline">{:ok, map}</code>, with string keys in the list converted to atoms. Ignores nested maps.</p>
<h3 id="atomorphify/2-examples" class="section-heading">
  <a href="#atomorphify/2-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.atomorphify(%{&quot;allowed_key&quot; =&gt; &quot;exists&quot;, &quot;non_existent_atom&quot; =&gt; &quot;does_not&quot;, 1 =&gt; &quot;is_ignored&quot;}, [&quot;allowed_key&quot;])
{:ok, %{ &quot;non_existent_atom&quot; =&gt; &quot;does_not&quot;, 1 =&gt; &quot;is_ignored&quot;, allowed_key: &quot;exists&quot;}}
</code></pre>

  </section>
</div>
<div class="detail" id="atomorphify!/1">
  
  
  <div class="detail-header">
    <a href="#atomorphify!/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">atomorphify!(map)</span>
    
    
    
      <div class="specs">
        
          <pre>atomorphify!(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()) :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a map as an argument and returns the same map with string keys converted to atom keys. Does not examine nested maps.</p>
<h3 id="atomorphify!/1-examples" class="section-heading">
  <a href="#atomorphify!/1-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.atomorphify!(%{&quot;this&quot; =&gt; &quot;map&quot;, &quot;has&quot; =&gt; %{&quot;string&quot; =&gt; &quot;keys&quot;}})
%{this: &quot;map&quot;, has: %{&quot;string&quot; =&gt; &quot;keys&quot;}}

iex&gt; Morphix.atomorphify!(%{1 =&gt; &quot;2&quot;, &quot;1&quot; =&gt; 2, &quot;one&quot; =&gt; :two})
%{1 =&gt; &quot;2&quot;, &quot;1&quot;: 2, one: :two}
</code></pre>

  </section>
</div>
<div class="detail" id="atomorphify!/2">
  
  
  <div class="detail-header">
    <a href="#atomorphify!/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">atomorphify!(map, allowed)</span>
    
    
    
      <div class="specs">
        
          <pre>atomorphify!(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(), :safe) :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()</pre>
        
          <pre>atomorphify!(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>()) :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a map and a list of allowed strings to convert to atoms and returns the same map, with string keys in the list converted to atoms. Ignores nested maps.</p>
<h3 id="atomorphify!/2-examples" class="section-heading">
  <a href="#atomorphify!/2-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.atomorphify!(%{&quot;allowed_key&quot; =&gt; &quot;exists&quot;, &quot;non_existent_atom&quot; =&gt; &quot;does_not&quot;, 1 =&gt; &quot;is_ignored&quot;}, [&quot;allowed_key&quot;])
%{&quot;non_existent_atom&quot; =&gt; &quot;does_not&quot;, 1 =&gt; &quot;is_ignored&quot;, allowed_key: &quot;exists&quot;}
</code></pre>

  </section>
</div>
<div class="detail" id="compactiform/1">
  
  
  <div class="detail-header">
    <a href="#compactiform/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">compactiform(map)</span>
    
    
    
      <div class="specs">
        
          <pre>compactiform(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>()) ::
  {:ok, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()}
  | {:ok, <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>()}
  | {:error, %ArgumentError{__exception__: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(), message: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()}}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Removes keys with nil values from maps and nil elements from lists. It also handles nested maps and lists, and treats empty maps as nil values.</p>
<h3 id="compactiform/1-examples" class="section-heading">
  <a href="#compactiform/1-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.compactiform(%{a: nil, b: &quot;not&quot;, c: %{d: nil, e: %{}, f: %{g: &quot;value&quot;}}})
{:ok, %{b: &quot;not&quot;, c: %{f: %{g: &quot;value&quot;}}}}

iex&gt; Morphix.compactiform(%{has: %{a: [&quot;list&quot;, &quot;with&quot;, nil]}, and: [&quot;a&quot;, %{nested: &quot;map&quot;, with: nil}]})
{:ok, %{has: %{a: [&quot;list&quot;, &quot;with&quot;]}, and: [&quot;a&quot;, %{nested: &quot;map&quot;}]}}

iex&gt; Morphix.compactiform([&quot;list&quot;, %{a: &quot;map&quot;, with: nil, and_empty: []}])
{:ok, [&quot;list&quot;, %{a: &quot;map&quot;, and_empty: []}]}

iex&gt; Morphix.compactiform(5)
{:error, %ArgumentError{message: &quot;expecting a map or a list, got: 5&quot;}}
</code></pre>

  </section>
</div>
<div class="detail" id="compactiform!/1">
  
  
  <div class="detail-header">
    <a href="#compactiform!/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">compactiform!(map)</span>
    
    
    
      <div class="specs">
        
          <pre>compactiform!(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>()) ::
  <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>() | %ArgumentError{__exception__: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(), message: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Removes keys with nil values from nested maps, eliminates empty maps, and removes nil values from nested lists.</p>
<h3 id="compactiform!/1-examples" class="section-heading">
  <a href="#compactiform!/1-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.compactiform!(%{nil_nil: nil, not_nil: &quot;a value&quot;, nested: %{nil_val: nil, other: &quot;other&quot;}})
%{not_nil: &quot;a value&quot;, nested: %{other: &quot;other&quot;}}

iex&gt; Morphix.compactiform!(%{nil_nil: nil, not_nil: &quot;a value&quot;, nested: %{nil_val: nil, other: &quot;other&quot;, nested_empty: %{}}})
%{not_nil: &quot;a value&quot;, nested: %{other: &quot;other&quot;}}

iex&gt; Morphix.compactiform!([nil, &quot;string&quot;, %{nil_nil: nil, not_nil: &quot;a value&quot;, nested: %{nil_val: nil, other: &quot;other&quot;, nested_empty: %{}}}, [&quot;nested&quot;, nil, 2]])
[&quot;string&quot;, %{not_nil: &quot;a value&quot;, nested: %{other: &quot;other&quot;}}, [&quot;nested&quot;, 2]]
</code></pre>

  </section>
</div>
<div class="detail" id="compactify/1">
  
  
  <div class="detail-header">
    <a href="#compactify/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">compactify(map_or_list)</span>
    
    
    
      <div class="specs">
        
          <pre>compactify(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>()) ::
  {:ok, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()}
  | {:ok, <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>()}
  | {:error, %ArgumentError{__exception__: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(), message: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()}}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a map or a list and removes any keys or elements that have nil values.</p>
<h3 id="compactify/1-examples" class="section-heading">
  <a href="#compactify/1-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.compactify(%{nil_key: nil, not_nil: &quot;real value&quot;})
{:ok, %{not_nil: &quot;real value&quot;}}

iex&gt; Morphix.compactify([1, nil, &quot;string&quot;, %{key: :value}])
{:ok, [1, &quot;string&quot;, %{key: :value}]}

iex&gt; Morphix.compactify([a: nil, b: 2, c: &quot;string&quot;])
{:ok, [b: 2, c: &quot;string&quot;]}

iex&gt; Morphix.compactify(%{empty: %{}, not: &quot;not&quot;})
{:ok, %{not: &quot;not&quot;}}

iex&gt; Morphix.compactify(&quot;won&#39;t work&quot;)
{:error, %ArgumentError{message: &quot;expecting a map or a list, got: \&quot;won&#39;t work\&quot;&quot;}}
</code></pre>

  </section>
</div>
<div class="detail" id="compactify!/1">
  
  
  <div class="detail-header">
    <a href="#compactify!/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">compactify!(map)</span>
    
    
    
      <div class="specs">
        
          <pre>compactify!(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>()) ::
  <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>() | %ArgumentError{__exception__: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(), message: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a map or list and removes keys or elements that have nil values, or are empty maps.</p>
<h3 id="compactify!/1-examples" class="section-heading">
  <a href="#compactify!/1-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.compactify!(%{nil_key: nil, not_nil: &quot;nil&quot;})
%{not_nil: &quot;nil&quot;}

iex&gt; Morphix.compactify!([1, nil, &quot;string&quot;, %{key: :value}])
[1, &quot;string&quot;, %{key: :value}]

iex&gt; Morphix.compactify!([a: nil, b: 2, c: &quot;string&quot;])
[b: 2, c: &quot;string&quot;]

iex&gt; Morphix.compactify!(%{empty: %{}, not: &quot;not&quot;})
%{not: &quot;not&quot;}

iex&gt; Morphix.compactify!({&quot;not&quot;, &quot;a map&quot;})
** (ArgumentError) expecting a map or a list, got: {&quot;not&quot;, &quot;a map&quot;}
</code></pre>

  </section>
</div>
<div class="detail" id="equaliform?/2">
  
  
  <div class="detail-header">
    <a href="#equaliform?/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">equaliform?(list1, list2)</span>
    
    
    
      <div class="specs">
        
          <pre>equaliform?(<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>()) ::
  <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">boolean</a>() | %ArgumentError{__exception__: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(), message: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes two ordered or unordered lists and returns <code class="inline">true</code> if they are equal.</p>
<h3 id="equaliform?/2-examples" class="section-heading">
  <a href="#equaliform?/2-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.equaliform?([1, [&quot;two&quot;, :three], %{a: 1, c: &quot;three&quot;, e: %{d: 4, b: 2}}], [[&quot;two&quot;, :three], 1, %{c: &quot;three&quot;, a: 1, e: %{b: 2, d: 4}}])
true

iex&gt; Morphix.equaliform?([1, &quot;two&quot;, :three, %{a: 1, c: &quot;three&quot;, e: %{g: 4, b: 2}}], [&quot;two&quot;, :three, 1, %{c: &quot;three&quot;, a: 1, e: %{b: 2, d: 4}}])
false

iex&gt; Morphix.equaliform?(%{a: 1, b: 2, c: 3}, %{b: 2, c: 3, a: 1})
** (ArgumentError) expecting a list for each parameter, got: %{a: 1, b: 2, c: 3}, %{a: 1, b: 2, c: 3}
</code></pre>

  </section>
</div>
<div class="detail" id="morphiflat/1">
  
  
  <div class="detail-header">
    <a href="#morphiflat/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">morphiflat(map)</span>
    
    
    
      <div class="specs">
        
          <pre>morphiflat(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()) :: {:ok | :error, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>() | String}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a map and returns a flattened version of that map. If the map has nested maps (or the maps nested maps have nested maps, etc.) morphiflat moves all nested key/value pairs to the top level, discarding the original keys.</p>
<h3 id="morphiflat/1-examples" class="section-heading">
  <a href="#morphiflat/1-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.morphiflat %{this: %{nested: :map, inner: %{twonested: :map, is: &quot;now flat&quot;}}}
{:ok, %{nested: :map, twonested: :map, is: &quot;now flat&quot;}}
</code></pre>
<p>In the example, the key <code class="inline">:this</code> is discarded, along with the key <code class="inline">inner</code>, because they both point to map values.</p>
<p>Will return <code class="inline">{:error, &lt;input&gt; is not a Map}</code> if the input is not a map.</p>
<h3 id="morphiflat/1-examples" class="section-heading">
  <a href="#morphiflat/1-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.morphiflat({1,2,3})
{:error, &quot;{1, 2, 3} is not a Map&quot;}
</code></pre>

  </section>
</div>
<div class="detail" id="morphiflat!/1">
  
  
  <div class="detail-header">
    <a href="#morphiflat!/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">morphiflat!(map)</span>
    
    
    
      <div class="specs">
        
          <pre>morphiflat!(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()) :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a map and returns a flattend version of that map, discarding any nested keys.</p>
<h3 id="morphiflat!/1-examples" class="section-heading">
  <a href="#morphiflat!/1-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples:
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.morphiflat! %{you: &quot;will&quot;, youwill: %{be: &quot;discarded&quot;}}
%{you: &quot;will&quot;, be: &quot;discarded&quot;}
</code></pre>

  </section>
</div>
<div class="detail" id="morphify/2">
  
  
  <div class="detail-header">
    <a href="#morphify/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">morphify(enum, funct)</span>
    
    
    
      <div class="specs">
        
          <pre>morphify([<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>()], (... -> <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>())) :: {:ok | :error, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>() | <a href="https://hexdocs.pm/elixir/String.html#t:t/0">String.t</a>()}</pre>
        
          <pre>morphify(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">tuple</a>(), (... -> <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>())) :: {:ok | :error, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>() | <a href="https://hexdocs.pm/elixir/String.html#t:t/0">String.t</a>()}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a List and a function as arguments and returns <code class="inline">{:ok, Map}</code>, with the keys of the map the result of applying the function to each item in the list.</p>
<p>If the function cannot be applied, will return <code class="inline">{:error, message}</code></p>
<h3 id="morphify/2-examples" class="section-heading">
  <a href="#morphify/2-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.morphify([[1,2,3], [12], [1,2,3,4]], &amp;Enum.count/1)
{:ok, %{1 =&gt; [12], 3 =&gt; [1,2,3], 4 =&gt; [1,2,3,4]}}

iex&gt; Morphix.morphify({[1,2,3], [12], [1,2,3,4]}, &amp;length/1)
{:ok, %{1 =&gt; [12], 3 =&gt; [1,2,3], 4 =&gt; [1,2,3,4]}}

iex&gt; Morphix.morphify([1,2], &amp;String.length/1)
{:error, &quot;Unable to apply &amp;String.length/1 to each of [1, 2]&quot;}
</code></pre>

  </section>
</div>
<div class="detail" id="morphify!/2">
  
  
  <div class="detail-header">
    <a href="#morphify!/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">morphify!(enum, funct)</span>
    
    
    
      <div class="specs">
        
          <pre>morphify!([<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>()], (... -> <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>())) :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()</pre>
        
          <pre>morphify!(<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">tuple</a>(), (... -> <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>())) :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Takes a list and a function as arguments and returns a Map, with the keys of the map the result of applying the function to each item in the list.</p>
<h3 id="morphify!/2-examples" class="section-heading">
  <a href="#morphify!/2-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.morphify!([[1,2,3], [12], [1,2,3,4]], &amp;Enum.count/1)
%{1 =&gt; [12], 3 =&gt; [1,2,3], 4 =&gt; [1,2,3,4]}
</code></pre>

  </section>
</div>
<div class="detail" id="partiphify/2">
  
  
  <div class="detail-header">
    <a href="#partiphify/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">partiphify(list, k)</span>
    
    
    
      <div class="specs">
        
          <pre>partiphify(<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">integer</a>()) ::
  {:ok, [<a href="https://hexdocs.pm/elixir/Access.html#t:get/2">list</a>(<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>())]} | {:error, <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Divides a list into k distinct sub-lists, with partitions being as close to the same size as possible</p>
<h3 id="partiphify/2-examples" class="section-heading">
  <a href="#partiphify/2-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.partiphify([1,2,3,4,5,6], 4)
{:ok, [[3], [4], [5, 1], [6, 2]]}

iex&gt; Morphix.partiphify((&quot;abcdefghijklmnop&quot; |&gt; String.split(&quot;&quot;, trim: true)), 4)
{:ok, [[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], [&quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;], [&quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;], [&quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;]]}</code></pre>

  </section>
</div>
<div class="detail" id="partiphify!/2">
  
  
  <div class="detail-header">
    <a href="#partiphify!/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <span class="signature">partiphify!(list, k)</span>
    
    
    
      <div class="specs">
        
          <pre>partiphify!(<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">integer</a>()) :: [<a href="https://hexdocs.pm/elixir/Access.html#t:get/2">list</a>(<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>())] | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">no_return</a>()</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Divides a list into k distinct sub-lists, with partitions being as close to the same size as possible</p>
<h3 id="partiphify!/2-examples" class="section-heading">
  <a href="#partiphify!/2-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples
</h3>

<pre><code class="iex elixir">iex&gt; Morphix.partiphify!([1,2,3,4,5,6], 4)
[[3], [4], [5, 1], [6, 2]]

iex&gt; Morphix.partiphify!((&quot;abcdefghijklmnop&quot; |&gt; String.split(&quot;&quot;, trim: true)), 4)
[[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], [&quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;], [&quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;], [&quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;]]
</code></pre>

  </section>
</div>

        </section>
      

      
          <footer class="footer">
        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" rel="help" target="_blank">ExDoc</a> (v0.18.3),
          </span>
          <span class="line">
            designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" title="@dignifiedquire">Friedel Ziegelmayer</a>.
            </span>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>
  <script src="dist/app-574613960f.js"></script>
  
  
  
  
  </body>
</html>

